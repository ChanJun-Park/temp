---
layout: post
comments: true
title:  "[청년취업아카데미] JAVA 1일차 JAVA 소개 및 개발환경 셋팅, 자료형"
date:   2020-07-17 22:07:51 +0900
categories: study
---
## JAVA 소개

### JAVA의 특성

자바는 제임스 고슬링이라는 프로그래머가 C/C++ 을 기반으로 만든 언어이다. C/C++ 가 갖고 있던 불편한 점을 개선하였는데 개선점은 다음과 같다.

- C/C++에 비해서 `Simple` 하다.
- C/C++ 개발에서 어렵고 불편하게 느껴졌던 `포인터` 를 제거했다.
- C/C++의 포인터와 연관된 메모리 생성 및 소멸 연산을 자동으로 수행하게 한다. 메모리 소멸 처리를 자동으로 해주는 것을 GC(Garbage Collector)라고 한다.
- C/C++과 비교했을때, 멀티 쓰레딩(Multi Threading)을 상당히 쉽게 구현할 수 있다.
- 운영체제에 Independent 하다. C/C++ 과 같은 언어로 작성된 프로그램은 특정 운영체제 상에서 동작하기 때문에 운영체제에 종속적이다.
 
운영체제에 종속적이라는 말은 운영체제가 어떤 동작을 지원하는 지, 또는 어떤 명령을 실행하고자 했을 때 어떤 코드를 써야하는 지가 달라질 수 있다는 뜻이다. 그러나 자바 언어로 작성된 프로그램은 운영체제에 종속적이지 않다. 이 같은 특징은 자바 프로그램이 운영체제 위가 아니라 JVM(Java Virtual Machine) 위에서 동작한다는 특징에서 기인한다. JVM은 자바 프로그램과 운영체제 사이에 위치하여 자바로 작성된 프로그램(자바 바이트 코드)을 JVM이 설치된 운영체제에서 동작할 수 있도록 해석(Interpret) 하는 역할을 한다.

#### 하이브리드 언어 : Compile 방식 + Interpreter 방식

자바는 Compile 방식과 Interpreter 방식을 합친 `하이브리드 언어` 이다. 자바로 작성된 소스파일은 자바 컴파일러에 의해서 `자바 바이트코드` 라는 중간 단계의 프로그램 파일로 변한다. 이 후 자바 런타임에서 해당 프로그램을 실행할때, `바이트코드` 가 의미하는 명령을 JVM이 설치된 운영체제에서 동작할 수 있는 명령으로 해석하는 과정을 거친다.

### JAVA 버전별 특성

- JAVA 1.4 : 인터넷 익스플로러에서 애플릿을 실행할 수 있는 JVM이 제거되자 이를 대응하기 위해서 등장한 버전이다.
- JAVA 5.0 : 1.x 와 같이 소수점 아래 한 자리를 올려가면서 버전관리를 하던 것을 정수 일의 자리를 변경하는 것으로 바꿨다. 그만큼 메이저한 변경이 일어났기 때문에 이전 버전과 호환이 되지 않을 수 있다. 제네릭, printf, 어노테이션과 같은 기능들이 추가되었다.
- JAVA 8.0 : 함수형 프로그래밍 기능이 추가되었다. 또한 JAVA 8 (1.8)에서 부터 라이센스가 적용되어 자바 언어를 사용하기 위해서 비용을 지불하게 되었다.

## 개발환경 세팅하기

### OpenJDK 1.8 설치하기

1. 여기 링크 (https://github.com/ojdkbuild/ojdkbuild) 들어가서 java-1.8.0-openjdk-1.8.0.252-2.b09.ojdkbuild.windows.x86_64.zip (sha256) 파일 다운로드 받기. 그 다음 원하는 폴더에 압축 풀기.
2. 제어판 > 시스템 및 보안 > 시스템 페이지로 이동. 왼쪽 고급 시스템 설정 클릭. 환경변수 버튼 클릭.
3. 시스템 변수의 새로 만들기 버튼 클릭. 변수 이름은 `JAVA_HOME`으로 설정하고 변수 값은 `C:\java\java-1.8.0-openjdk-1.8.0` 와 같이 압축 해제했던 폴더에서 bin 폴더의 상위 폴더까지의 경로를 입력한다.
4. 시스템 변수 중 `Path` 변수를 찾아서 클릭한 다음 편집 버튼 클릭. 새로 만들기 버튼을 클릭한 후 `%JAVA_HOME%/bin` 을 입력한다. 이는 명령프롬프트에서 현재 작업디렉토리(pwd) 가 어느 위치에 있더라도, `javac`, `java`와 같은 프로그램을 실행할 수 있도록 설정해주는 것이다.
5. 다시 시스템 변수의 새로 만들기 버튼을 클릭한다. 이번에는 변수 이름을 `CLASSPATH`로 입력하고, 변수 값은 `.;` 로 입력한다.

### 명령 프롬프트로 자바 파일 컴파일 및 실행해보기

자바 프로그래밍을 할 경우 이클립스와 같은 IDE에서 개발하는 것이 대부분이지만, IDE 없이도 자바 프로그램을 컴파일하고, 실행할 수 있다. 자바 파일을 컴파일 할 때 `JAVA_HOME/bin` 폴더에 있는 `javac` 라는 도구를 사용한다. 명령 프롬프트에서 이 프로그램을 사용하여 자바 소스 파일을 컴파일 할 수 있다. 

메모장이나 에디트텍스트와 같은 프로그램을 이용해서 먼저 자바 소스 파일을 작성한다. 모든 자바 소스파일은 다음과 같은 구조를 갖는다.

1. 파일 이름과 소스파일 내에서 정의하는 클래스 이름을 동일하게 설정한다.
2. 클래스 이름은 관례적으로 대문자로 시작한다.
3. 해당 클래스를 프로그램의 진입점으로 설정하기 위해서는 main 메소드를 추가한다.

```java
class Test {

    public static void main(String[] args) {
        System.out.println("Hello Wolrd");
    }

}
```

자바 소스 파일은 `.java` 라는 확장자를 갖는다. 이제 명령 프롬프트를 실행해서 cd 명령을 이용해서 해당 소스파일이 있는 경로로 이동한 다음 아래와 같이 컴파일 한다.

```sh
$javac Test.java
```

그럼 폴더에 `Test.class` 라는 클래스 파일이 생성된다. 이 클래스 파일을 메모리에 로드해서 실행시키려면 다음과 같은 명령어를 실행하면 된다.

```sh
$java Test
```

#### 패키지 구조

자바에서는 클래스 파일들을 의미있는 그룹으로 나누고, 다른 동작을 수행하면서 동일한 이름을 갖는 클래스들의 이름 충돌을 해결하기 위해서 `패키지(Package)` 구조를 사용한다. 패키지를 선언하기 위해서 자바 소스 파일 상단에 다음과 같이 적는다.

```java
package day01;

class Test {

    public static void main(String[] args) {
        System.out.println("Hello Wolrd");
    }

}
```

위와 같이 작성하면 day01 이라는 폴더가 만들어지고 그 폴더안에 class 파일이 생성된다. 패키지는 폴더의 역할을 하지만 단순히 폴더 역할만을 하는 것은 아니다. 패키지 이름은 클래스의 이름을 구성하는 중요한 속성이며 위의 `Test` 클래스는 `import` 구문의 사용 없이는 `day01.Test`와 같이 정확히 명시되어야 사용할 수 있다. 패키지 이름은 모두 소문자로 작성하는 것이 관례이다.

명령 프롬프트 상에서 패키지와 함쎄 자바 클래스 파일을 생성하고 싶다면 `-d` 옵션을 추가하여 패키지가 생성될 폴더를 지정해주어야 한다.

```sh
$javac -d <폴더이름> <자바 소스파일 이름.java>
```

### 자바 IDE 설치하기 : 이클립스

1. eclipse.org 사이트 접속. 우상단 다운로드 버튼 클릭
2. 최신 버전의 이클립스를 설치할 수 있는 버튼이 있지만, 최신 버전보다 좀 더 안정성이 있는 예전 버전을 설치하는 것이 좋다. 다운로드 버튼 아래의 Download Packages 를 클릭
3. 오른쪽 MORE DOWNLOADS 탭에서 원하는 버전 클릭. 자바8을 사용한다면 `photon` 이상의 버전을 사용해야한다. 지금은 `2019-12` 버전을 클릭
4. `Eclipse IDE for Enterprise Java Developers` 을 다운로드 받는다. `Eclipse IDE for Enterprise Java Developers` 는 `Eclipse IDE for Java Developers`에서 제공하는 기본적은 자바 개발에 더하여 서버개발에 필요한 구성요소들이 포함되어 있다.
5. 다운로드 받은 압축파일을 풀면 압축해제된 폴더에 eclipse.exe 파일을 곧바로 실행하여 사용할 수 있다.

#### eclipse.ini

압축을 푼 폴더에는 `eclipse.ini` 파일이 있는데 이 파일에 이클립스 실행과 관련된 설정을 해줄 수 있다.

```ini
...
-Xms256m
-Xmx1024m
--add-modules=ALL-SYSTEM
```

파일의 마지막 부분에 `-Xms256m`, `-Xmx1024m` 과 같은 설정은 이클립스를 실행하기 위해서 필요한 메모리 크기를 의미한다. 후자는 힙과 같이 expandable한 메모리의 최대 크기를 설정하는 것 같다. 개발하는 시스템의 메모리가 모자란 경우 이 설정을 수정하여 사용할 수 있다.

#### 이클립스 기본 설정 : 문자 인코딩

1. 이클립스 실행. 상단 메뉴에서 Window > Preferences > General > Workspace 로 들어가서 Text file encoding을 UTF-8로 변경
2. General > content type 에서 Java Class file 선택 후 아래 Default Encoding을 UTF-8로 수정
3. General > content type 에서 JSP 파일도 동일한 방식으로 수정
4. Web 탭에서 CSS, HTML, JSP 파일에서도 문자열 인코딩 방식을 UTF-8로 수정

#### 이클립스 기본 설정 : Pespective

Pespective란 이클립스에서 모든 메뉴를 화면에 표시하는 것이 아니라, 특정개발을 위해서 필요한 메뉴만을 화면에 표시하도록 하는 방법이다. 상단 메뉴 아래 툴바 메뉴에서 맨 오른쪽(X 종료버튼 아래)를 보면 현재 Perpective가 보인다. Perpective 버튼의 왼쪽을 보면 Perpective를 수정할 수 있는 버튼이 있다. 이 버튼을 클릭한 후 원하는 Perpective로 설정할 수 있다. 자바 개발만을 위해서는 Java Perpective를 클릭

### 새 프로젝트 생성

1. 상단 메뉴의 File > New > Java Project 버튼 클릭 또는 툴바 메뉴의 첫번째 아이콘을 클릭해서 새 프로젝트 파일 추가 또는 `Ctrl + n` 단축키로 새로운 파일을 생성할 수 있다.
2. 프로젝트 생성 대화상자에서 프로젝트 이름 설정
3. next 버튼을 클릭하면 이클립스를 통해서 생성한 자바소스 파일과 클래스 파일이 어느 폴더에 저장될 지를 설정할 수 있다. 이를 확인한 뒤 finish 클릭

### 패키지 생성하고 첫번째 소스파일 작성

1. 왼쪽 탭에서 `src` 폴더 아이콘에서 마우스 오른쪽 버튼 클릭, new > package 클릭. 패키지 명 입력 후 Finish
2. 패키지 아이콘에서 마우스 오른쪽 클릭, New > class 선택.
3. class 생성 대화상자에서 클래스 이름 설정 및 접근제한자, 기본적으로 생성할 메소드 등을 설정하고 Finish 버튼 클릭

#### 첫번째 소스 파일 분석

```java
package day01;

public class Sample01 {

	public static void main(String[] args) {
		System.out.println("Hello World");
	}
	
}
```

- `public` : 해당 클래스가 다른 클래스에서도 사용될 수 있음을 의미한다.
- `static` : New 키워드를 통해 메모리에 로드할 필요 없이 이미 메모리에 로드되어 있어 사용할 수 있음을 나타낸다.
- `main` : c언어의 main 함수와 같이 프로그램의 진입점을 나타낸다. 클래스와 클래스 내부에 있는 메소드나 멤버 변수들은 먼저 new 키워드를 통해서 메모리에 로드한 다음 사용해야 하지만 이 메소드는 static으로 선언되어 있어서 이미 메모리에 로드되어 있기 때문에 곧바로 호출할 수 있다.
- 클래스 : Data + Function

#### 유용한 단축키들

- `Ctrl + alt + ↑ ↓` : 행단위 복사
- `Ctrl + space` : 코드 자동 추천
- `alt + ↑ ↓` : 행 이동

## 변수와 데이터 타입

### 자바의 데이터 타입

자바의 데이터 타입은 2가지 종류로 구분된다.

- `Primitive Type` : char(2바이트 유니코드 문자), byte(1바이트 정수), short(2바이트 정수), int(4바이트 정수), long(8바이트 정수), float(4바이트 실수), double(8바이트 실수), boolean(1바이트 부울 변수)
- `Reference Type` : 메모리 상에 로드된 클래스 객체의 주소(참조값)을 나타내는 타입이다. `null` 은 아직 어떤 클래스 객체도 가리키지 않는 다는 의미이다. Reference Type의 변수들에 제때 제때 null asign을 해주자. 자바가 자동적으로 GC를 수행하여 메모리를 관리하기는 하지만 Reference Type의 변수에 의해 참조가 되고 있는 객체들에 대해서는 GC를 하지 않기 때문이다.

### 암시적 형변환(promotion)과 명시적 형변환(casting)

기본적으로 자바 변수는 같은 타입의 값만을 저장할 수 있다. (같은 타입의 변수들끼리만 연산할 수 있다.) 다른 타입의 값이 들어오는 경우 해당 값을 변수의 타입으로 변경하려는 시도를 한다. 이 때 적용되는 규칙은 다음과 같다.

- 데이터의 손실이 일어날 수 있는 경우 컴파일 에러를 발생시킨다.
- 데이터의 손실이 발생하지 않을 경우 암시적 형변환(promotion)을 진행한다.

#### 데이터의 손실이 일어날 수 있는 경우

```java
int num1 = 0;
long num2 = 3000000000;  //1 컴파일 에러 발생

num1 = num2;  //2 컴파일 에러 발생
```

위 코드에서 int 형 변수 num1은 최대 2,147,483,647(2^31- 1) 까지 저장할 수 있기에 이보다 큰 값을 저장하고 있는 num2 변수의 값(3000000000)를 num1 에 할당할 경우 데이터 손실이 발생할 수 있다. 따라서 컴파일 에러가 발생한다.

위 코드는 2번째 라인에서도 에러가 발생한다. 기본적으로 자바에서 소수점이 없는 정수 리터럴은 int 형 변수로, 소수점이 있는 실수 리터럴은 float 형 변수로 인식하기 때문에 3000000000과 같이 int형 변수로 처리할 수 없는 상수 리터럴을 사용하는 경우 컴파일 에러가 발생한다. 이같이 큰 정수 리터럴이 `long` 형 타입임을 알리기 위해서는 뒤에 `l`을 추가하면 된다.

```java
long num2 = 3000000000l;
```

#### 데이터 손실을 감내하고 형변환 하기

```java
int num1 = 0;
long num2 = 3000000000l;

num1 = (int)num2; // 명시적 형변환 발생
```

만약 데이터의 손실이 일어나도 데이터 타입이 다른 변수에 값을 할당하고 싶다면 형변환 연산자를 사용하여 명시적으로 형변환을 해야한다.

#### 데이터의 손실이 일어나지 않는 경우

```java
int num1 = 0;
long num2 = 3000000000l;

num2 = num1;
```

위 처럼 더 큰 값을 저장할 수 있는 num2 변수에 그보다는 작은 값을 저장하는 num1 변수 값을 할당하는 경우 데이터의 손실이 일어나지 않기 때문에 자동으로 int 형 변수 num1을 long형으로 변환한뒤 할당을 진행한다.

### 문자열 관련 내용

```java
package day01;

public class Sample02 {

	public static void main(String[] args) {
		System.out.println("Hello world");
		System.out.println(1 + 2 + " : " + 3 + 4 + 5); // 3 : 345
		System.out.printf("%d", 10 + 3);
	}

}
```

- `System.out.println` : System 클래스의 io 관련 객체 중 `out` 객체를 사용하여 콘솔 화면에 문자데이터를 출력한다.
- `System.out.println(1 + 2 + " : " + 3 + 4 + 5);` : 문자열과 다른 타입을 `+` 기호로 연산하면 다른 타입의 값이 문자열로 변환되어 concatenation이 진행된다.
- `System.out.printf` 메소드를 이용해서 문자열 출력의 포맷을 지정해줄 수 있다.

1 + 2 + " : " + 3 + 4 + 5 와 같은 문자열 처리는 거의 사용하지 않는다. 이 같은 처리는 문자열 객체 생성을 빈번하게 수행하는데, 문자열 객체를 생성하는 작업은 부하가 많은 작업이기 때문에 이같은 코드는 성능 저하의 원인이 될 수 있다. 보통은 StringBuilder라는 클래스를 사용하여 문자열을 생성한다.
